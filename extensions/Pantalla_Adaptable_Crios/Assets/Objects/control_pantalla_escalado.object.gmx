<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Iniciar control de application surface

application_surface_draw_enable(false); //Se desactiva primero para manejarlo desde esta instancia

//Se definen los tamaños minimos a tener en cuenta en dibujar sobre la surface, usando el ancho y alto de la view activa
min_ancho = view_wview[0];
min_alto = view_hview[0];

//Valores a considerar dentro del script y para dibujar en postDraw
actual_ancho = 1;
actual_alto = 1; 

//Valores globales creados en macros para la posicion relativa de la GUI, en el script de escalar se setean
g_gui_x = 0;
g_gui_y = 0;
g_gui_ancho = 0;
g_gui_alto = 0;


//Script que se crea para el manejo del reescalado del surface
/*
    Por alguna razón, cuando creo esta instancia en un room que automaticamente va al siguiente, no lo adapta como debería.
 Generalmente yo tengo un room que inicia todos los objetos singleton y luego salta al siguiente room en el "room code", seguramente
es por un orden de ejecución (aunque también lo agrego como objeto del room y tampoco sucede).

    Por esta razón decide hacer dos script: el local y global. El local es usado por este objeto, mientras el global es una forma
simplificada de hacer que este objeto utilice ese método (ya que usa sus propios atributo).

    El global lo llamo en el "creation code" del siguiente room que me manda el rm_ini
    
*/

//sc_pantalla_escalar_local();



</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Verificiar si hay cambios en la ventana para redimensionar de nuevo

//Esto solo es necesario para que compruebe todo el tiempo, sino es mejor que solo se haga al principio o en el momento que se cambia la ventana

if( actual_ancho != window_get_width() or actual_alto != window_get_height() ){

    sc_pantalla_escalar();

}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="77">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Dibujar el application surface


/*

    Se estira el application surface para que corresponda al ancho y alto que estamos manejando.

    No hace falta preocuparse por la posición en que se dibuja el surface ya que siempre el aspect ratio sera el mismo
que el de la ventana.

*/


draw_surface_stretched(application_surface, 0, 0, actual_ancho, actual_alto);

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
